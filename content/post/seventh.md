---
title: "Paxos Simple 阅读笔记"
date: 2022-12-23T19:37:07+08:00
draft: false
math: mathjax
---

## 问题定义

什么是共识算法（Consensus Algorithm）：

一个集合中的每个进程都能对某个变量的值作出提案。共识算法保证在提案（proposed）的值中只有一个被选中（chosen）。如果没有值被提出，那么就没有
值被选中。如果已经有值被选中了，那么进程能够学习（learn）到这个选中的值。

共识算法的活性要求（safety requirements）：

- 在提案的值中只有一个能被选中
- 仅选择一个值
- 一个进程只有在值被选中后才能知道这个被选中的值

活性要求保证了某个被提案的值最终会被选中，如果一个值别选中之后，一个进程最终能够学习到这个值。

Paxos 算法中包含三类角色，分别是：

- proposers, 提案者：负责对变量的值进行提案
- acceptors，接受者：负责对提案进行决策 —— 接受或者拒绝
- learners，学习者：在值被选中之后，进行学习

在具体实现中，一个进程可能扮演多种角色。

假设进程之间可以通过消息进行通信。Paxos 使用常见的，异步的，非拜占庭（non-Byzantine）模型：

- 进程以任意速度运行，可能会因为由于崩溃而失败，可能重启。因为，进程完全有可能在一个值被选中后失败，然后重启，所以必须借助持久化存储来保存
一些决策信息。
- 消息会花费任意上的时间，可能会重复，可能会丢失，但是绝不可能被破坏。

## 如何选择一个值

### 单个 Acceptor

最简单的方法是只有一个acceptor。一个 proposer 发送一个提案（proposal）给 acceptor，acceptor **接受（accepted）第一个收到的提案**。

只有一个 Acceptor，最显而易见的问题是：如果它挂掉了，那么共识就无法进行下去。

### 多个 Acceptor

很自然的，我们想到使用多个 Acceptor 来选择一个值。既然有多个 Acceptor，那么 Proposer 将提案发送给多个 Acceptor。只有当足够多
的Acceptor接受了某个值，那么它才算被选中了。这是多个 Acceptor 下的选择策略。那多少才足够呢？超过半数。1/3 行不行呢？如果有 1/3 的 Acceptor
选中了某个值，另外 2/3 选中了另外一个值，这样就选中两个值，不满足算法的活性要求。那么 1/2 行不行呢？也是同样的问题。如果超过半数，根据鸽笼原理，
不可能有两个大小超过半数而没有交集的集合选中不同的值。

假设我们共有 5 个Acceptor，分别为 S1, S2, S3, S4, S5. 其中：
- S1, S2, S3 选中了值 v1
- S2, S4, S5 选中了值 v2

集合 {S1, S2, S3} 和 {S2, S4, S5} 之间存在交集 {S2}。如果要达成共识，即 `v1 = v2` 的话，S2 只能选择一个值。

因为 S1, S3 和 S2 选择相同， S4, S5 和 S2 选择相同，所以 Acceptor 之间达成了共识。

假如没有失败和消息丢失，在一个 Proposer 的情况下，并且该 Proposer 只提出了一个提案，那么这个提案应该被接受并选中。这意味着满足下面的要求：

```
P1. 一个 Acceptor 必须接受它收到的第一个提案
```

但是这个要求会导致一个问题。假设几个proposer各自提案了不同的值，导致每个acceptor都接受了一个值，但是没有一个值被大多数acceptor所接受。

P1 和 一个值被选中当且仅当被多数acceptor接受要求 acceptor 必须能够接受多个提案。这个结论看着很简单，却不是那么自然地容易得出。为什么 
acceptor 只接受一个提案就不能形成共识呢？前面提到，形成共识的前提是两个多数的交集接受了同一个值。

> 假设我们共有 5 个Acceptor，分别为 S1, S2, S3, S4, S5. 其中：
> - S1, S2, S3 选中了值 v1
> - S2, S4, S5 选中了值 v2

加入 S2 先接受了 v1, 那么 S1, S2, S3 接受了 v1, S4 和 S5 接受了 v2，v1 被多数接受，这不是形成了共识了吗？但如果 S2 挂掉，剩下的 S1, S3
与 S4, S5 分别接收了 v1 和 v2, 此时又形成了分裂。这种情况下不能形成共识。

我们已经通过例子证明了接受单个提案容易导致单点故障，那么不妨让acceptor能够接收多个提案。

“多个提案”，acceptor 如何知道收到的两条消息是不同的提案呢？我们给提案附加一个编号，这样的话提案就由两个部分组成：

- 提案编号
- 提案的值

为了避免混淆，我们要求不同的提案必须有不同的编号。这里的不同是指不同的消息。提案的内涵得到了扩容，值被选中的条件也需要稍作调整。

**一个值被选中当且仅当一个拥有该值的提案被大多数acceptor所接受。**

在这种情况下，我们说提案（包含它的值）被选中。

我们允许多个提案被选中，但是保证所有被选中的提案都有相同的值。编号肯定有大小，现在保证对于某个proposer而言，后发出的提案的编号更大。
如果多个提案被选中，那么后面的提案编号更大，但是值确实和被选中的值相同。即满足：

```
P2. 如果一个值为 v 的提案被选中，那么每个更高编号的被选中的提案的值也是 v
```

为什么要限制“更大的编号”呢？“如果一个值为 v 的提案被选中，那么后面被选中的提案的值也是 v”，这样说行不行呢？这是一个疑问。

为了被选中，一个提案至少要被一个acceptor所接受。所以，为了满足 P2，我们必须满足：

```html
P2^a 如果一个值为v的提案被选中之后，那么更大编号的由acceptor接收的提案的值也为 v.
```

有了 P2^a，我们仍然要满足 P1。假设一个提案被一个从未接受过任何提案的acceptor c 所接受。这时候一个新的 proposer 醒来了，发出了一个更大的
但是不同值的提案。P1 要求 c 接受这个提案，此时已经有多数接受了某个值，即已经有值被选中了，这样就违反了 P2^a。

为了同时满足 P1 和 P2^a，要求我们加强 P2^a 到 P2^b

```html
P2^b 如果一个值为v的值已经被选中，那么任何更大的编号由proposer发出的提案的值都是v
```

因为一个提案是先由 proposer 发出，然后由 acceptor 接收，所以由 P2^b 可以满足 P2^a，间接满足 P2.

为了发现如何满足 P2^b，让我们考虑如何证明它成立。

假设已经有编号为 m, 值为 v 的提案被选中，那么需要证明任何编号大于 m 的编号 n 的提案的值也是 v.

我们可以在 n 上面使用数据归纳法从而简化证明。我们可以证明在假设编号在 m..(n-1) 之间的提案都有值 v 的前提下证明满足 P2^b.

当编号为 m 的编号的提案被选中时，肯定有一个包含多数的集合 C，其中的 acceptor 都接受了它。将这个情况与归纳假设结合起来，m 被选中意味着：

> Every acceptor in C has accpeted a proposal with number in m..(n-1), and every proposal with number in m..(n-1)
accepted by any acceptor has value v.

因为任意多数的集合 S 至少包含 C 的一个元素，我们通过维护下面的不变性来保证编号为 n 的 提案也有值 v:

```text
P2^c 对于任意 v 和 n, 如果编号为 n, 值为 v 的提案发出后，
存在一个多数 acceptor 的集合 S 满足下面两个条件：

(a) S 中没有 acceptor 接受过编号小于 n 的提案

或者

(b) v 是 S 中acceptor所接收到的编号小于 n 的最大编号的提案的值。 
```

我们因此可以维护 P2^c 进而来满足 P2^b.

为了维护 P2^c，一个 proposer 如果想发出一个编号为 n 的提案，必须学习到编号小于 n 的最大编号的提案（如果有的话），这个提案已经或者将要被某些
多数集合的 acceptor 所接受。

proposer 要求 acceptor 不在接受任意编号小于 n 的提案。这样就形成了下面的发出提案的算法：

1. 一个 proposer 选择一个新的提案编号 n，并向acceptor的某个集合发出请求，要求它们响应：

(a) 许诺不再接受任何编号小于 n 的提案

(b) 如果有的话，返回acceptor所接受的最大的编号小于n的提案

这样的请求叫做一个 *prepare* 请求。

2. 如果 proposer 收到多数 acceptor 的应答，那么它可以发出一个编号为 n, 值为 v 的提案；其中 v 是它收到的所有响应中最大编号的提案的值，或者
它自己提议的值，如果没有收到任何响应的话。

一个 proposer 发出一个提案请求 acceptor 接收它的提案。这个请求叫做 **accept** 请求。

上面两步描述了 proposer 的算法。acceptor 的算法是怎样的呢？
