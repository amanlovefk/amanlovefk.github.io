---
title: "Basic Paxos Deduction From single Proposer's Perspective"
date: 2022-12-24T16:30:50+08:00
draft: false
---

Paxos 算法的精髓在于其推导的过程。

Paxos 算法中本质上只需要两种角色：proposer 和 acceptor。故事就发生在这两个角色之间。

在正式开始推导之前，需要明确的一点是：何种情况下**谁**认为达成了共识？明确“谁”的主体意味着我们需要切换视角，从 proposer 的角度，还是从 
acceptor 的角度，或是从上帝的视角？答案是我们要从 proposer 的角度来明确当前系统是否已经达成了共识。

“何种情况呢？” proposer 向所有 acceptor 发出一轮请求，如果返回的响应中的大多数的值是相同的，那么 proposer 就认为系统已经达成了共识；并把
该值返回给客户端。Paxos 算法强调的似乎是写，如果去读呢？也需要进行标准的 Paxos 算法过程，最后获得的那个值就是读取到的值。

每个 proposer 之间是平等的，独立的，proposer 之间并不会发生通信。在 Multi Paxos 算法中，为了提高共识算法的效率，会进行选主，这时候 
proposer 之间会发生通信。现在我们讨论的是 Basic Paxos，proposer 之间不知道彼此的存在。

我们接下来的推导过程都要戴着单个 proposer 的帽子，看看这个微小的个体是如何参与到这个令人眼花缭乱的协议和过程中去的。

## 单个 Acceptor 

> 故事在最开始的那个梦中，漫天星光只因我而闪烁 ...

让我们回到故事的起点，那时候我们还没有那么贪婪。只有一个 acceptor，有多个 proposer。这唯一的 acceptor 对于 proposer 提出的值如何决策呢？

等等，proposer 发出的消息格式是什么样子呢？虽然，我们站在第一级台阶上，也要搞清楚一些基本问题。这时候，协议还很简单：

- proposer 向唯一的 acceptor 发出了消息，消息中唯一包含的就是提议的值，除此之外没有任何其他东西。

- acceptor 收到之后如何反应呢？

Paxos 算法的活性要求我们必须要能够达成对一个值的共识，如今这个重任就放到唯一的 acceptor 身上。acceptor 可以采取两种行动：一是接受（accept),
二是拒绝（reject）。如果接受，接受哪个呢？毕竟 acceptor 对值没有偏好，proposer 之间也是众生平等，不能因为碰巧遇到了某个值就接受了它。换句话
说，对于 acceptor 来说，值本身不能给它提供决策需要的信息。acceptor 只能从其他维度来定义自己的接收规则。

我们需要一个规则，但是又不确定这个规则是什么？路有千万条，该走哪一条，哪一条又是活路呢？此时，我们无妨（不得不）假设我们的算法已经成型，现在要
用它来进行经常测试。先从最简单的场景开始。

如果只有一个 proposer，它只发出了一个提案，也就说整个系统中只有一个提案，那么最终的共识自然是这个提案了。收到提案的 proposer 该如何反应呢？
拒绝吗？拒绝之后也没有其他提案了，无法达成共识。这个 proposer 只能接收这个唯一的提案。我们的接收规则可能非常复杂，但在当下这种一个proposer，
一个提案和一个acceptor的情况下它必须**蕴含**能达成的情况。我们观察一下，对于 acceptor 来说，这个唯一的提案有什么特征。前面提到了，acceptor
不会从值本身来决定接收还是拒绝，那么在这里，这个孤单的提案的特征是什么呢？是的，就是“一个”这个特征。一个意味着是第一个也是最后一个。目前，我们
的消息格式十分简陋，只有一个值，到 acceptor 这里的话，由于多个消息的存在，给消息附加了时间信息。

如果 acceptor 按照接收的顺序来决定接收规则呢？ 或者说 acceptor 接收它收到的每个提案。后面这种想法明显不靠谱，如果acceptor如何来者不拒，
系统的共识将会无法收敛。我们还是考虑从顺序上来定义接受规则。在只有一个提案的情况下，acceptor 可以将规则定义为：

- a: 接收第一个收到的提案
- b: 接收最后一个收到的提案

a 还是 b 呢？如果选 b, “最后一个”是一个相对的概念，意味着接下来没有收到任何消息。而在基于消息的共享模型中，一个消息可能会花费任意长的时间达到，
确定最后一个必须要有一个时间的限制，比如3分钟内。而 Paxos 算法中是没有这样的时间限制的，因此我们只能将规则定义为：

```text
P1 一个Acceptor必须接受它收到的第一个提案
```

P1听起来有点过于简单，就这？？？别看人家轻描淡写的一句话，在现在这个场景（只有一个 proposer 只发出了一个 提案 给唯一的 acceptor）下是够用的。
当然，我们能隐约感受到它是一个局部的真理。就好像，火鸡养殖场里面，有一只练习时长不满一年的火鸡科学家，它观察到每天下午，它的住处都会出现事物，
于是它推测每天下午都会出现食物，这是一个真理。殊不知，在11月第四个星期三，下午没有出现食物，反而出现一位从未见过的巨人把它抓起来了。因为明天就是
感恩节，它被用来“感恩”了。

人类的记忆容纳不了太多没有逻辑的内容，因为这意味着我们不是踩着台阶上去了，而是从某种无法预测难以理解的地方突然达到了彼岸。我必须介绍一下我们继续
推导的思路，这对急需理解的读者们是一个救赎，不过，首先是自我的救赎。

我们首先假设大厦已经建成，然后有这个幻想去满足一些基本的场景，得到一个基本的简单的局部的规则。这个就是我们思维的起点。之后，我们进行如下的循环：

- A: 通过反例发现已有规则的漏洞
- B: 提出更加完善的规则

如果幸运的话，我们会在若干个循环后停在B。but, who knows ? 鉴于现在是 2022 年，是 Paxos 算法发表的30多年后，所以我们都心知肚明这是一次
装模作样的推导，我们会成功的，只要是很自然地被我们大脑所接受。

目前我们的 B 是 P1, 接下我们要对他进行挑刺。

## 多个 Acceptor 

一个 acceptor 为啥不行？很简单，如果它挂掉了，proposer 将一直苦等，从它的角度来看，无法达成共识，这就违反了算法的活性要求。一个不行就多个吧。
毕竟，在分布式系统中我们的印象是，多个，有好多个， 服务器不止一个，而是一个集群，给我们提供“高可用”的服务。挂掉一个，不影响服务可用性。

既然是多个 acceptor，我们系统的可用性得到了保证，但是对于共识来说事情变得复杂起来。在只有一个 acceptor 的情况下，proposer 在回复中得到
确认后就认为自己的提案变成了共识。现在有多个acceptor，这些交互的过程又是怎样呢？

如果 proposer 只给一个 acceptor 发送请求，如果幸运的话，这个熟悉的战友挂掉的话，proposer 只能一直等下去了。所以，不仅决策端要配备多个 
acceptor，proposer 也要灵活起来，不能把所有的鸡蛋都放在同一个篮子里，它决定给多个 proposer 都发送请求。那么，proposer 到底应该给多少个
acceptor 发送请求才能保证不会出现没人会它的情况呢？

等等，我们的系统不会要求出现所有的 acceptor 都挂掉还能正常进行共识协议工程吗？这可能吗？所以我们在讨论proposer该给多少个 acceptor 发送
消息之前，我们需要对于 acceptor 的集群故障做一个限制：在何种故障程度下共识算法要能够容忍错误并正常工作。

这种故障是指什么呢？Paxos 算法针对的是非拜占庭式的故障模型。对于 acceptor 来说，它可能会运行缓慢，宕机或者重启，但是不可能会破坏或者修改
或者欺骗 proposer，也就说，这里的故障没有“魔法”的存在。何种故障程度值得是集群中有几个可以正常工作（活的的，能产生响应的）。

Paxos 算法的工作的前提是 acceptor 中的多数可用，假设有 5 个 acceptor 节点，之中3个及以上的节点可用就能保证算法正常运行。

我们再回到proposer应该给多少个acceptor发送消息的问题上来。按照人类民主议会制的少数服从多数的选举制度的朴素思想，proposer 至少收到多数
的 acceptor的接受响应后，才可以认为自己的提案已经成为系统的共识。所以最简单的方法是给所有的acceptor都发送消息。

如果共有5个acceptor，其中3个接受了提案，但是中途挂掉了一个，所以只有两个接收的响应。这种情况下，proposer 就不能认为自己的提案被选中。这是一
个反例，也是我们后面要解决的问题。

现在我们需要明确从 proposer 的角度来说，怎样算达成了共识。proposer 在收到的消息中发现有多数接受了自己，就认为共识达成。这是 proposer 端的
决策规则。那么 acceptor 端又该如何定义接受规则呢？

我们先沿用 P1 这个接受规则。P1 实际限制了只能接收第一个收到的提案，意味如果可以接收第二个，那么共识就无法变得难以收敛（当然这是我们的一个直觉，
没有严谨的证明，目前为止，我们还在一系列的猜想当中，完全可以自由行路）。在多个 proposer 同时提案的过程中，acceptor 按照接收的值被划分成多个
不相交的集合。比如在记为 S1 ~ S5 的 acceptor 集群中根据收到的值 v1, v2, v3形成了互补相交的三个集合： {S1, S2}, {S3}, {S4, S5}。
这样就无法形成多数了。

假设为了 v1 让成为多数，proposer1 向 S3 又发出了请求，然后 S3 接受了它。这样我们就无法使用 P1 这个简单的接收规则了。需要修改 acceptor 的
接受规则，怎么改呢？首先排除掉接收每一个收到的提案。接收相同值的提案怎么样？但是在上面的情形中，还是无法形成共识。假如 proposer1, proposer2,
proposer 3 都坚持己见，不肯妥协，那么算法是无法达到安全性的。proposer必须要作出让步，毕竟算法的目的是达成共识，进而保证多副本的状态一致，而
不是从单个 proposer 的利益考虑。如果一个 proposer 能够学习到其他 proposer 的提案并进行跟随，那么就有可能形成多数的接受。

proposer 如何学习呢？在正式发出提案之前，先进行一轮查询，询问 acceptor 们是否有已经接受的提案。如果查询过后，没有发现任何接受的提案，它就广播
自己的提案了。这是理想化的情况，假如已有接受的提案了，它应该跟随哪一个提案，以便整个系统快速收敛？到现在为止，提案就是值本身，而不同的值对于
proposer 来说没有什么区别，它需要额外的信息。

acceptor 不能接收每一个收到的提案，如果它接收收到的第一个提案，并接受之后收到的相同值的提案，这样会不会对上面的分裂情形产生帮助呢？并不会。

proposer1, proposer2, proposer 3 失败之后，再进行一轮查询，这时候返回的值有 v1, v2, v3。且不说选择哪一个，就算选择任意一个，继续发出
请求也不会形成多数派，因为 acceptor 那里已经不会修改接受的提案了。在 acceptor 的接受规则这里已经到头了，不能玩出新的花样了。

再次明确一下现在的情况，proposer有3个，分别是proposer-1, proposer-2, proposer-3, acceptor 有5个，分别是S1 ~ S5.
- proposer-1 提出的 v1 被 S1, S2 接收；
- proposer-2 提出的 v2 被 S3 接收；
- proposer-3 提出的 v3 被 S4, S5 接收。

proposer 的工作过程已经发生了改变，为了学习在失败时追随可能已经成为多数的提案，加速共识的快速收敛，首先要进行一轮查询请求，然后根据情况再发出
一轮提案。目前我们进退两难，分裂的局面难以进行下去，整个系统陷入无效工作的循环当中。

我们能不能避免这种分裂的情况呢？proposer-1,2,3 刚开始查询的返回结果中都显示没有任何已经接收的提案，所以它们随机写入自己的提案。假如我们想让
v1 称为共识，能不能在第一轮查询的时候告知 acceptor 不要接收其他 proposer 的值？这样第二轮的时候肯定能够多数派写入成功。现在 acceptor 不仅
要区分不同的值，还要区分不同的 proposer，那么给每个把每个 proposer 的编号在查询时传递给 acceptor 吧。可是，别忘了，在分布式系统中，每个
proposer 的行为是并发的，假设 proposer-1 给一个多数派集合 Q1 发送了查询请求，这样 Q1 中每个 acceptor 都记住了 proposer-1；同时，
proposer-2 给另一个多数派集合 Q2 发送了查询请求，Q2 和 Q1 肯定有交集，交集中至少有一个元素，记作 S_0。这个 S_0 到底是记住 proposer-1，
还是 proposer-2 呢？如果记住收到的第一个查询请求的 proposer，之后这个 proposer 挂掉了，那么这个 acceptor 就废掉了，无法参与投票了；所以，
记住最新的查询请求的 proposer。

第一轮查询时有必要的，首先它是一个学习共识的过程。然后我们对其附加了额外的操作，要求 acceptor 承诺不再接受其他 proposer 的提案。第一轮请求
称为 Prepare 请求。 第二轮请求称为 Accept 请求。这样对于 proposer 来说整个提案过程分为两个阶段（2-Phase）。

如果运气不好，proposer-1 在 Prepare 请求中对他许诺的 acceptor 在中途被更新的 Prepare 请求拐跑了，那么 proposer-1 将会在 Accept 请求
中收到接受到的提案，这时候应该选择哪一个跟随呢？返回的响应中可能包含proposer-1自己发出的提案。

似乎进行不下去了，让我们来看看 Paxos 在 P1 之后的进展吧。

只接受一个值会导致分裂，那么允许接收多个值吧，只是这些值要相同。这和我们的推导似乎有点相似。Paxos 算法给每个提案附加了一个编号，每个 Proposer
发出的提案的编号是严格递增的，且不同的proposer发出的提案编号没有重叠。这引出了 P2.

```text
P2. 如果一个值为 v 的提案被接受了，那么每个更大编号的被接收的提案的值也都是 v.
```

与我们的推导不同的是，Paxos 给提案附加了编号。这是不太自然很难想到的地方。也许，我们的推导还需要参阅更多的资料，而不是从零开始。

P2 有两个推论:

```text
P2_a. 
如果一个值为 v 的提案被接受了，那么被 acceptor 接收的更大编号的提案的值也都是 v.

P2_b. 
如果一个值伪 v 的提案被接受了，那么由 proposer 发出的更大编号的提案的值也都是 v.
```

那么 proposer 如何学习到这个已经被接收的提案的值呢？通过 Prepare 请求，这和我们的推导吻合。P2_a 和 P2_b 分别对 acceptor 消费端和 acceptor
生产端都提出了要求。

[//]: # (我们快到 Paxos 推导的最后一步了。)

那么前面分裂的情况解决了吗？并没有。我们仍然需要 acceptor 在 Prepare 请求时给我们一些承诺，Paxos这里导出 P2 的第三个推论：

```text
P2_c. 对于编号为 n，值为 v 的提案被一个多数派 S 接收，则 S 中的acceptor 满足：

(a) 没有任何 acceptor 接受过任何编号小于 n 的提案

(b) 在接收过的编号小于 n 的最大编号的提案的值也是 v
```

P2_c 对 acceptor 提出了更为具体化的要求。Prepare 阶段要学习的提案就是编号小于 n 的最大提案的值；那么 acceptor 的承诺是什么，在 Prepare
请求中不接受比 n 小的请求；在 Accept 请求中，不接受编号比 n 小的请求。这就是新的规则：

```text
P1_a.
一个acceptor接收编号为 n 的提案当且仅当它没有响应过任何编号大于n的prepare请求。
```
这里的响应其实就是许诺，不响应就是不许诺。
