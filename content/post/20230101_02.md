---
title: "Paxos 共识算法（第一次尝试）"
date: 2023-01-01T19:05:02+08:00
draft: false
---

## 共识问题

对于一个变量来说，假设有一系列的进程都可以对它的值发出提议。共识（consensus）算法保证在这些提议（proposed）的值中只有一个能被选中（chosen）。如果没有提议，那么就不会有值被选中。如果一个值被选中之后，进程能够学习到（learn）这个被选中的值。

共识算法的安全性要求如下：
- 提议中的值才能被选中被
- 只有一个值能被选中
- 只有被选中的值被确定下来之后，进程才能学习到这个值

在 Paxos 算法中主要有两种类型的角色：

- proposers：提案者，负责对变量的值发出提案。
- acceptors：接受者，负责对提案进行决策。

在实际的实现当中，一个进程可能在不同时刻担任不同的角色。

我们假设进程之间通过消息进行通信，并使用异步的、非拜占庭式的故障模型：
- 进程可能会以任意的速度运行，可能会崩溃，可能会重启。值别选中之后然后进程重启了，这种情况完全有可能，所以共识算法必须要采取持久化存储来保证进程崩溃和重启之后仍然能够记住某些决策信息。
- 进程发送的消息送达的耗时是不确定的，可能会花费非常长的时间，可能会重复、丢失，但是绝不会被篡改（非拜占庭）。

## 如何选择一个值

最简单的方法是只有一个acceptor。一个 proposer 发送一个提案（proposal）给 acceptor，acceptor 接受（accepted）第一个收到的提案。
只有一个 Acceptor，最显而易见的问题是：如果它挂掉了，那么共识协议就无法进行下去。

为了避免单点故障，我们采用使用多个 acceptor 才参与决策。proposer 将提案请求发送给每个 acceptor，如果其中多数的acceptor接受了它的提案，那么该提案就被选中了。这里的多数是指超过1/2。这时有没有可能出现两个值都被选中了呢？我们假设存在这种情况，被选中的值分别为 v1 和 v2，接受它们的acceptor集合分别为 S1 和 S2，且 v1 不等于 v2. 由于 S1 和 S2 都是多数的acceptor集合，它们之间必有交集。如果 v1 和 v2 都被选中了，说明它们的交集 S 中的acceptor至少接受了两个不同的提案。这就违反了算法的安全性要求，我们希望有且只有一个值被选中，因此我们需要对 acceptor 的决策行为作出限制，即：acceptor 最多只能接收一个提案。

此时，我们需要明确一下提案的内容，目前为止，提案就是值对变量的取值，不包含其他内容。

此时，我们可以回答小节的标题“如何选择一个值”？答案就是：当acceptor中的多数接受了（accepted）一个提案时，它就被选中（chosen）了，它就是acceptor和proposer达成的共识。

##  Paxos 算法的推导

现在我们只知道提案被选中的判定方式，而算法对于 acceptor 和 proposer 施加怎样的限制以及两者交互的协议如何设计还不得而知。下面我们将从最简单的情景出发，逐步推导出整个算法的流程。

假设我们的算法设计已经完成，那么它肯定能满足一些最简单的场景。

###  从最简单的场景出发

假设我们现在只有一个 proposer，它只发出了一个提案，在没有消息丢失或者进程崩溃的情况下，我们想让这个唯一的提案被选中。这听起来有点难以理解。如果这样想：整个系统里面只有一个提案，那它成为共识不是很自然的事情吗？毕竟，没有任何其他人提出任何其他的意见。这里，我们有意忽略了时间这个要素，但是可以继续假设一个极端的情形，在无限远的时间内，只有这一个提案，我们必须要接受它。这就对于 acceptor 提出了一个最简单的决策要求：

`P1. 一个 Acceptor 必须接受它收到的第一个提案`

在上面极端的情形中，如果 acceptor 不接受它收到的这个唯一的提案，我们便不能形成这各想当然的唯一的共识。但是为什么是“第一个”呢？在只有一个提案的情况，以“第一个”和“最后一个”来描述它达到的顺序同样正确。因为“最后一个”隐含了对于时间的要求，比如“在3分钟内的最后一个”，“在过去7天内的最后一个”，然而，我们的算法并不对时间作出限制，所以判定“最后一个”是不可能的。

P1 的要求如此简陋，我们可以轻而易举地找到它的一个问题场景：

![image](http://git.lonsun.cn/ex9-project/project-knowledge/uploads/babd2fc566d6cab2578248740b88b8e3/image.png)

在如图所示的场景中，S1 到 S5 既是proposer 也是  acceptor，它们可以向自身发出提案和接收自身的提案。proposer 和 acceptor 是同一个进程的情况是比较常见的。

S1 向 S1, S2 发出 red 的提案，并被接受；S3 向 S3 和 S4 发出 blue 的提案，并被接受；S5 向自身发出提案并被接受。此时，任意一种值都不能形成多数，如果 S1 再像向 S3 发出请求，由于 S3 已经接受了 blue（收到的第一个提案），而且 red 不等于 blue，S4 和 S5 也是如此。所以 S1 提案的 red 在第一轮提案中不可能成为共识; S3 和 S5 也同样失败了。S1 再次发次提案行不行呢？由于acceptor不能撤销它接受的提案，所以除了 S1 和 S2 之外它不可能再取得其他 acceptor 的接受。共识过程陷入了死局。

### 先协商再提案

如果 S1 在正式进行提案之前先和所有的acceptor打个招呼，等会我提案的时候你只接受我的，其他 proposer 都要拒绝掉。我们将打招呼的请求称为 Prepare 请求，将正式的提案请求称为 Accept 请求。

为了正确地履行给 proposer 的承诺，acceptor 必须要能够区分不同的 proposer。为此，proposer 可以将自己的唯一标志发送给 acceptor，并让它记住。比如 S1 的标志就是 1，S3 的标志就是 3。问题又来了，在 Prepare 请求中 acceptor 记住的 proposer 能不能更改呢？这个问题似乎和提案的值能不能更改有点类似。必须要能更改。假如 S2 在 Prepare 请求中承诺只接受 S1 的提案，结果 S1 在这时候突然挂掉了，此后再也没有醒来。S2 这个决策者就这样干巴巴地等着 S1 的 Prepare 请求，并履行承诺拒绝其他 proposer 的请求，等于 S2 陷入了一个死锁的情况，资源无法释放。如果要能更改的话，从锁的角度来说，S2 就变成了一个可抢占的锁。

可是如果在 Prepare 请求中 acceptor 记住的 proposer 可以更改的话，岂不是 acceptor 的承诺是没有保证的吗？例如：S1 前脚收到了 S2 的承诺，后脚 S2 就又答应了 S3 了。干脆让 S2 承诺之后拒绝其他 proposer 的 Prepare 请求算了。但这样又会回到之前的说的由于 proposer 故障导致 acceptor 一直被占用的情况。

又要能变，又不能随意地变？等等，acceptor 的承诺一直变化的话也许对于结果没有影响。

我们继续看看 Accept 请求，S2 此时在将自己的标志加上提案发送给所有的acceptor，如果幸运的话，多数 acceptor 接受了它的提案，从返回的响应里面，S2 得知自己的提案已经被选中。那么问题又来了，其他 proposer 如何学习到这个值呢？在 Accept 请求的回应中或者更早一点在 Prepare 请求的响应中，如果一个 acceptor 已经接受了某个提案，将它返回给 proposer，然后 proposer 从中选取一个提案的值并使用它发出 Accept 请求，这样系统就能对变量的值的认知快速收敛。

下面我们明确一下这两个请求的过程：

1. Prepare 请求：proposer 将自己的标志发给所有 acceptor，如果响应中包含提案的话，就从中选择一个值作为自己的提案。

2. Accept 请求：proposer 将自己的标志加上提案的中发送给所有 acceptor，如果半数以上的 acceptor 回复接受的话，那么 proposer 就认定自己的值被选中。否则重复步骤1.

在 Prepare 请求的响应中，proposer 可能接收到多个提案的值，从中选择哪一个进行跟随才能更快加速共识收敛呢？
或者说，这些不同的提案哪一个更有利于共识的形成？需要明确的是，我们对提案的值没有偏好，各个 proposer 之间是平等的，我们不会偏爱某个值。因此，必须对提案附加一些额外的信息来定制一些规则加速共识收敛。

### 给提案附加编号

如果我们给每个提案一个编号，类似于数据库中的主键，然后在选择提案进行追随时选择那个编号最大的，仅仅这样做就可以了吗？

现在我们的提案不仅仅是值那么简单，还有编号。所以，完整的提案结构包含两个部分：提案的编号，提案的值。

假设我们已经知道了被选中的值，怎么让它在整个共识协议过程中逐渐地披露出来呢？

我们回头想一想，proposer 在 Prepare 请求阶段收到的提案中随机选一个作为自己提案的值，这样行不行呢？有可能行，但我们的要求是算法必须能够正确地得到答案，而不是有时行，有时不行。

如果 proposer 选择了那个编号最大的提案作为自己的提案，acceptor 应该也要修改一下规则以保证更大编号的提案优先被接受。发生在多个进程之间的算法过程也可以看做协议，需要多边都作出举措以促进结果的形成。

acceptor 目前的决策规则是能够接收相同值的提案，为了使得编号更大提案有更大的优先级，我们需要调整一下规则：

`P2. 如果一个值为 v 的提案已经被选中，那么任何更大编号的被接收的提案的值也是 v.`

那么更小编号的提案呢？那就需要拒绝掉，要不然使用编号大小形成的优先级无法保证。我们的初衷是利用编号形成的优先级规则帮助整个系统更快地达到共识，换句话说，我们要让已经某个多数派接收的值更快地传播到系统内的所有节点上。

由于只有 acceptor 才能对提案进行接受或者拒绝，很自然地，我们由 P2 推导出：

`P2_a：如果一个值为v 的提案已经被选中，那么任意acceptor接受的更大编号的提案的值都是 v`。

“更大的”编号总有一个标准，它比较就是这个已经接受的提案的编号。

我们的规则变得越来越复杂，但是它仍然要满足最简单的场景。试想：假设在一个提案被选中后，有一个proposer经过prepare阶段后碰巧发现acceptor还没有接收过任意提案，于是便发出了更大编号的提案给了一个从未接受过任何提案的acceptor，而此时其他acceptor已经对某个提案形成多数，按照 P1，这个acceptor必须接受当前的提案，可是这又违反了 P2_a。为了同时满足 P1 和 P2_a，必须对 proposer 提出的提案进行限制：

`P2_b：如果一个值为v的提案已经被选中，那么任意proposer发出的更大编号的的提案的值都是 v`.

可是，一个proposer在正式提案之前如何得知已经被选中的值呢？这又回到了我们说到的从 Prepare 请求的响应中挑选一个提案的问题了 ———— 选择编号最大的那个。

### 目前为止的流程梳理

从 proposer 的角度：

1. Prepare 阶段：proposer 向所有 acceptor 发送请求，要求它们只接受自己的提案。在收到的响应中如果有提案，选择那个编号最大的提案的值作为自己的提案的值；如果没有的话，使用自己的值。

2. Accept 阶段：proposer 向所有 acceptor 发送提案请求，包含proposerId、提案编号和提案的值。要求它们接受自己的提案。如果收到半数以上的接受恢复，就认为自己的提案成为了共识。

从 Acceptor 的角度：

1. 收到 Prepare 请求：将proposerId 存储下来，如果已经有接受的提案，返回给proposer。

2. 收到 Accept 请求：如果已经有接受的提案，并且当前请求的编号大于当前接受的提案的编号，就接受该提案，返回OK。如果小于接受的提案的编号，就拒绝。如果没有接受过任何提案，且请求的 proposerId 与存储的 proposerId 相同，接受该提案，返回 Ok；否则，返回拒绝响应。

如果我们将 proposerId 从请求参数中移除，仅仅使用提案的编号，那么算法流程如下：

从 proposer 的角度：

1. Prepare 阶段：proposer 向所有 acceptor 发送请求，要求它们不能接收比当前编号小的提案。在收到的响应中如果有提案，选择那个编号最大的提案的值作为自己的提案的值；如果没有的话，使用自己的值。

2. Accept 阶段：proposer 向所有 acceptor 发送提案请求，包含提案编号和提案的值。要求它们接受自己的提案。如果收到半数以上的接受恢复，就认为自己的提案成为了共识。

从 Acceptor 的角度：

1. 收到 Prepare 请求：如果有接受的提案，且编号比当前请求小，更新存储的编号，回复OK，并带上接收的提案；如果编号比当前请求大，则拒绝当前的prepare请求，回复拒绝。如果没有接收的提案，且没有接收过 prepare 请求，储存当前的编号；如果已经收到过 Prepare 请求，如果编号被当前请求大，则拒绝当前的prepare请求；否则，更新存储的编号。

2. 收到 Accept 请求：如果编号大于存储的值，则接收值；
